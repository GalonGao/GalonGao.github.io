(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{343:function(a,t,e){"use strict";e.r(t);var i=e(3),s=Object(i.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分类","aria-hidden":"true"}},[a._v("#")]),a._v(" 分类")]),a._v(" "),e("ol",[e("li",[a._v("强缓存： 一定时间内只能去缓存，Cache-Control（public, max-age=xxx）和Expire两个字段控制。 版本发布了咋整，后端更新，前端还在走缓存，gg了。")]),a._v(" "),e("li",[a._v("协商缓存： 每次都要向服务器验证一下缓存的有效性，通过（Last-modified/If-Modified-Since，Etag/If-None-Match）控制，嗯。。。。对于一个有追求的码农，这是不能接受的。\n"),e("ul",[e("li",[a._v("last-modified 和 Etag 区别：")])]),a._v(" "),e("ol",[e("li",[a._v("某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新。")]),a._v(" "),e("li",[a._v("Last-modified 只能精确到秒。")]),a._v(" "),e("li",[a._v("一些资源的最后修改时间改变了，但是内容没改变，使用 Last-modified 看不出内容没有改变。")]),a._v(" "),e("li",[a._v("Etag 的精度比 Last-modified 高，属于强验证，要求资源字节级别的一致，优先级高。")])])])]),a._v(" "),e("hr"),a._v(" "),e("p",[e("strong",[a._v("注")]),a._v(" ETag计算：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('- Nginx中是"文件最后修改时间16进制-文件长度16进制"。例：ETag： “59e72c84-2404”\n- Express框架中：方式一：使用文件大小和修改时间；方式二：使用文件内容的hash值和内容长度；\n')])])]),e("h3",{attrs:{id:"最佳实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践","aria-hidden":"true"}},[a._v("#")]),a._v(" 最佳实践")]),a._v(" "),e("ul",[e("li",[a._v("在做前端缓存时，我们尽可能设置长时间的强缓存，通过文件名加hash（webpack配置）的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。")])])])},[],!1,null,null,null);t.default=s.exports}}]);